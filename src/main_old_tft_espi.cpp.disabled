/* Main entry for the board. Initializes LVGL + TFT_eSPI and loads the UI
   generated by SquareLine Studio (files in `src/` like ui.c, ui.h, ui_Screen1.c)
*/

#include <Arduino.h>
#include <lvgl.h>
#include <TFT_eSPI.h>
#include "ui.h"
#include <esp_system.h>

// Change to match your SquareLine / display project resolution
static const uint16_t screenWidth  = 480;
static const uint16_t screenHeight = 480;

// Small buffer portion - adjust if you have more PSRAM
static lv_color_t buf[ screenWidth * screenHeight / 20 ];

TFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */

// put function declarations here:

/* Debug LED for quick hardware troubleshooting.
 * You can override DEBUG_LED_PIN by adding -DDEBUG_LED_PIN=<pin> to build_flags
 * or by defining it before including this file. */
#ifndef DEBUG_LED_PIN
  #ifdef LED_BUILTIN
    #define DEBUG_LED_PIN LED_BUILTIN
  #else
    #define DEBUG_LED_PIN 13
  #endif
#endif

static inline void ledInit(void)
{
    pinMode(DEBUG_LED_PIN, OUTPUT);
    digitalWrite(DEBUG_LED_PIN, LOW);
}

static inline void blinkPattern(uint8_t times, uint16_t onMs, uint16_t offMs)
{
    for(uint8_t i = 0; i < times; i++) {
        digitalWrite(DEBUG_LED_PIN, HIGH);
        delay(onMs);
        digitalWrite(DEBUG_LED_PIN, LOW);
        delay(offMs);
    }
}


/* Quick TFT sanity test - enable by setting RUN_TFT_SANITY_TEST to 1 */
#ifndef RUN_TFT_SANITY_TEST
  #define RUN_TFT_SANITY_TEST 1
#endif

/* Quick way to isolate firmware issues: compile with RUN_MINIMAL_TEST=1 to skip TFT/LVGL
   and run a simple LED blink + serial heartbeat. Useful when the board disconnects
   or resets during display init. Set to 1 to disable display. */
#ifndef RUN_MINIMAL_TEST
  #define RUN_MINIMAL_TEST 1
#endif

static void quickTFTSanityTest(void)
{
#if RUN_TFT_SANITY_TEST
    Serial.println("Quick TFT sanity test: filling colours...");

    /* Print pin mapping so we can detect if DEBUG_LED_PIN and TFT_BL are the same */
#ifdef TFT_BL
    Serial.printf("DEBUG_LED_PIN=%d, TFT_BL=%d\n", (int)DEBUG_LED_PIN, (int)TFT_BL);
#else
    Serial.printf("DEBUG_LED_PIN=%d, TFT_BL=UNDEFINED\n", (int)DEBUG_LED_PIN);
#endif

    /* Turn on the LED during the test so you can see activity even if display is off */
    digitalWrite(DEBUG_LED_PIN, HIGH);

    /* Ensure correct byte order for RGB565 if needed */
    tft.setSwapBytes(true);

    /* Simple color fills and a message to verify hardware and backlight */
    tft.fillScreen(TFT_MAGENTA);
    delay(800);
    tft.fillScreen(TFT_GREEN);
    delay(600);
    tft.fillRect(10, 10, screenWidth - 20, screenHeight - 20, TFT_WHITE);
    tft.setTextSize(2);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
    tft.setCursor((screenWidth / 2) - 36, (screenHeight / 2) - 8);
    tft.print("TFT OK");
    delay(600);

    /* Leave the final test image visible (do not clear to black) so we can see results */

    /* If the LED and backlight are different pins, turn the LED off now. */
#ifdef TFT_BL
    if (DEBUG_LED_PIN != TFT_BL) digitalWrite(DEBUG_LED_PIN, LOW);
#else
    digitalWrite(DEBUG_LED_PIN, LOW);
#endif

#endif
}


#if LV_USE_LOG != 0
/* Serial debugging for LVGL */
void my_print(const char * buf)
{
    Serial.printf("%s", buf);
    Serial.flush();
}
#endif

/* Display flushing (LVGL v9 API) - toggles debug LED while flushing */
void my_disp_flush( lv_display_t * disp, const lv_area_t *area, uint8_t * px_map )
{
    /* Indicate flush start */
    digitalWrite(DEBUG_LED_PIN, HIGH);

    uint32_t w = ( area->x2 - area->x1 + 1 );
    uint32_t h = ( area->y2 - area->y1 + 1 );

    tft.startWrite();
    tft.setAddrWindow( area->x1, area->y1, w, h );
    /* px_map contains raw pixel data in the display color format (RGB565 here) */
    tft.pushColors( ( uint16_t * )px_map, w * h, true );
    tft.endWrite();

    lv_display_flush_ready( disp );

    /* Indicate flush end */
    digitalWrite(DEBUG_LED_PIN, LOW);
}

/* Simple (dummy) touch pad reader - replace with actual touch code if available */
void my_touchpad_read( lv_indev_t * indev, lv_indev_data_t * data )
{
    /* No touch available by default */
    data->state = LV_INDEV_STATE_RELEASED;
}

void setup()
{
#if RUN_MINIMAL_TEST
    /* Ultra-minimal test: ZERO GPIO, only serial prints */
    Serial.begin(115200);
    delay(200);

    Serial.println("MINIMAL TEST BOOT - NO GPIO");
    Serial.printf("Reset reason: %d\n", (int)esp_reset_reason());
    Serial.println("Setup complete - entering loop with serial-only heartbeat");
    Serial.flush();

    /* Do not touch any GPIO pins at all */
#else
    Serial.begin( 115200 );
    delay(100);

    Serial.println("Starting LVGL + SquareLine UI");
    Serial.printf("Reset reason: %d\n", (int)esp_reset_reason());
    Serial.println("Before lv_init");

    lv_init();
    Serial.println("After lv_init");

#if LV_USE_LOG != 0
    lv_log_register_print_cb( my_print ); /* register print function for debugging */
#endif

    /* TFT init */
    tft.begin();
    tft.setRotation( 0 );

    /* Initialize debug LED and backlight (if defined in TFT config) */
    ledInit();
#ifdef TFT_BL
    pinMode(TFT_BL, OUTPUT);
    /* Start with backlight OFF to check for brownout / power issues */
    digitalWrite(TFT_BL, LOW); /* ensure backlight is off initially */
    Serial.println("TFT_BL set LOW (backlight disabled for debug)");
#endif

    Serial.println("Before quickTFTSanityTest");
    quickTFTSanityTest();
    Serial.println("After quickTFTSanityTest");

    blinkPattern(2, 80, 80); /* quick boot blink */

    /* Create and configure the display (LVGL v9 API) */

    lv_display_t * disp = lv_display_create(screenWidth, screenHeight);
    lv_display_set_default(disp); /* make it the default display so ui.c can use lv_display_get_default() */

    /* Configure buffers and flush callback */
    lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);
    lv_display_set_buffers(disp, buf, NULL, sizeof(buf), LV_DISPLAY_RENDER_MODE_PARTIAL);
    lv_display_set_flush_cb(disp, my_disp_flush);

    /* Register a simple (dummy) input device */
    lv_indev_t * indev = lv_indev_create();
    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(indev, my_touchpad_read);
    lv_indev_set_display(indev, disp);

    /* Initialize the UI generated by SquareLine */
    Serial.println("Before ui_init");
    ui_init();
    Serial.println("After ui_init");

    /* Indicate successful setup with LED blinks */
    blinkPattern(3, 150, 100);

    Serial.println("Setup done");
#endif
}

void loop()
{
#if RUN_MINIMAL_TEST
    static uint32_t lastHeartbeat = 0;
    uint32_t now = millis();
    if (now - lastHeartbeat >= 500) {
        /* Serial-only heartbeat: no GPIO operations */
        Serial.printf("HB %lu ms\n", now);
        Serial.flush();
        lastHeartbeat = now;
    }
    delay(10);
#else
    static uint32_t lastHeartbeat = 0;
    lv_timer_handler(); /* let the GUI do its work */

    uint32_t now = millis();
    if (now - lastHeartbeat >= 1000) {
        Serial.println("."); /* heartbeat every second */
        /* Toggle heartbeat LED so we can see MCU alive even if serial disconnects */
        static bool hbState = false;
        hbState = !hbState;
        digitalWrite(DEBUG_LED_PIN, hbState ? HIGH : LOW);
        lastHeartbeat = now;
    }

    delay( 5 );
#endif
}
