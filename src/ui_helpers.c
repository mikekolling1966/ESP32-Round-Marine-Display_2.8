// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui_helpers.h"
#include "screen_config_c_api.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <math.h>
#include "esp_log.h"

static const char *TAG_UI_HELPERS = "ui_helpers";

// C-linkage helper provided by a C++ file. Implemented in src/ui_runtime.cpp
float ui_get_runtime_value(int screen_idx, int gauge_idx);

void _ui_bar_set_property( lv_obj_t *target, int id, int val) 
{
   if (id == _UI_BAR_PROPERTY_VALUE_WITH_ANIM) lv_bar_set_value(target, val, LV_ANIM_ON);
   if (id == _UI_BAR_PROPERTY_VALUE) lv_bar_set_value(target, val, LV_ANIM_OFF);
}

void _ui_basic_set_property( lv_obj_t *target, int id, int val) 
{
   if (id == _UI_BASIC_PROPERTY_POSITION_X) lv_obj_set_x(target, val);
   if (id == _UI_BASIC_PROPERTY_POSITION_Y) lv_obj_set_y(target, val);
   if (id == _UI_BASIC_PROPERTY_WIDTH) lv_obj_set_width(target, val);
   if (id == _UI_BASIC_PROPERTY_HEIGHT) lv_obj_set_height(target, val);
}

void _ui_dropdown_set_property( lv_obj_t *target, int id, int val) 
{
   if (id == _UI_DROPDOWN_PROPERTY_SELECTED) lv_dropdown_set_selected(target, val);
}

void _ui_image_set_property( lv_obj_t *target, int id, uint8_t *val) 
{
   if (id == _UI_IMAGE_PROPERTY_IMAGE) lv_img_set_src(target, val);
}

void _ui_label_set_property( lv_obj_t *target, int id, const char *val) 
{
   if (id == _UI_LABEL_PROPERTY_TEXT) lv_label_set_text(target, val);
}

void _ui_roller_set_property( lv_obj_t *target, int id, int val) 
{
   if (id == _UI_ROLLER_PROPERTY_SELECTED_WITH_ANIM) lv_roller_set_selected(target, val, LV_ANIM_ON);
   if (id == _UI_ROLLER_PROPERTY_SELECTED) lv_roller_set_selected(target, val, LV_ANIM_OFF);
}

void _ui_slider_set_property( lv_obj_t *target, int id, int val) 
{
   if (id == _UI_SLIDER_PROPERTY_VALUE_WITH_ANIM) lv_slider_set_value(target, val, LV_ANIM_ON);
   if (id == _UI_SLIDER_PROPERTY_VALUE) lv_slider_set_value(target, val, LV_ANIM_OFF);
}

void _ui_screen_change( lv_obj_t ** target, lv_scr_load_anim_t fademode, int spd, int delay, void (*target_init)(void)) 
{
   if(*target == NULL)
      target_init();
   // Invalidate all cached images before switching screens to prevent stale images
   lv_img_cache_invalidate_src(NULL);
   lv_scr_load_anim(*target, fademode, spd, delay, false);
}

void _ui_arc_increment( lv_obj_t *target, int val) 
{
   int old = lv_arc_get_value(target);
   lv_arc_set_value(target, old+val);
   lv_event_send(target,LV_EVENT_VALUE_CHANGED, 0);
}

void _ui_bar_increment( lv_obj_t *target, int val, int anm) 
{
   int old = lv_bar_get_value(target);
   lv_bar_set_value(target, old+val, anm);
}

void _ui_slider_increment( lv_obj_t *target, int val, int anm) 
{
   int old = lv_slider_get_value(target);
   lv_slider_set_value(target, old+val, anm);
   lv_event_send(target,LV_EVENT_VALUE_CHANGED, 0);
}

void _ui_keyboard_set_target( lv_obj_t *keyboard, lv_obj_t *textarea) 
{
   lv_keyboard_set_textarea(keyboard, textarea);
}

void _ui_flag_modify( lv_obj_t *target, int32_t flag, int value)
{
    if (value==_UI_MODIFY_FLAG_TOGGLE)
    {
        if ( lv_obj_has_flag(target,flag) ) lv_obj_clear_flag(target,flag);
        else lv_obj_add_flag(target,flag);
    }
    else if (value==_UI_MODIFY_FLAG_ADD) lv_obj_add_flag(target,flag);
    else lv_obj_clear_flag(target,flag);
}
void _ui_state_modify( lv_obj_t *target, int32_t state, int value)
{
    if (value==_UI_MODIFY_STATE_TOGGLE)
    {
        if ( lv_obj_has_state(target,state) ) lv_obj_clear_state(target,state);
        else lv_obj_add_state(target,state);
    }
    else if (value==_UI_MODIFY_STATE_ADD) lv_obj_add_state(target,state);
    else lv_obj_clear_state(target,state);
}

void _ui_textarea_move_cursor(lv_obj_t * target, int val)
{
    if (val==UI_MOVE_CURSOR_UP) lv_textarea_cursor_up(target);
    if (val==UI_MOVE_CURSOR_RIGHT) lv_textarea_cursor_right(target);
    if (val==UI_MOVE_CURSOR_DOWN) lv_textarea_cursor_down(target);
    if (val==UI_MOVE_CURSOR_LEFT) lv_textarea_cursor_left(target);
    lv_obj_add_state(target, LV_STATE_FOCUSED);
}

typedef void (*screen_destroy_cb_t)(void);
void scr_unloaded_delete_cb(lv_event_t * e)
{
   // Get the destroy callback from user_data
    screen_destroy_cb_t destroy_cb = lv_event_get_user_data(e);
    if(destroy_cb) {
        destroy_cb();  // call the specific screen destroy function
    }
}

void _ui_opacity_set( lv_obj_t *target, int val) 
{
   lv_obj_set_style_opa(target, val, 0);
}

void _ui_anim_callback_free_user_data(lv_anim_t *a)
{
	lv_mem_free(a->user_data);
	a->user_data=NULL;
}

void _ui_anim_callback_set_x(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_obj_set_x(usr->target, v);
}

void _ui_anim_callback_set_y(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_obj_set_y(usr->target, v);
}

void _ui_anim_callback_set_width(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_obj_set_width(usr->target, v);
}

void _ui_anim_callback_set_height(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_obj_set_height(usr->target, v);
}

void _ui_anim_callback_set_opacity(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_obj_set_style_opa(usr->target, v, 0);
}

void _ui_anim_callback_set_image_zoom(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_img_set_zoom(usr->target, v);
}

void _ui_anim_callback_set_image_angle(lv_anim_t* a, int32_t v)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   lv_img_set_angle(usr->target, v);
}

void _ui_anim_callback_set_image_frame(lv_anim_t* a, int32_t v)
{
    ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
    usr->val = v;
    if ( v<0 ) v=0;
    if ( v>=usr->imgset_size ) v=usr->imgset_size-1;
    lv_img_set_src(usr->target, usr->imgset[v]);
}

int32_t _ui_anim_callback_get_x(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_obj_get_x_aligned(usr->target);
}

int32_t _ui_anim_callback_get_y(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_obj_get_y_aligned(usr->target);
}

int32_t _ui_anim_callback_get_width(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_obj_get_width(usr->target);
}

int32_t _ui_anim_callback_get_height(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_obj_get_height(usr->target);
}

int32_t _ui_anim_callback_get_opacity(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_obj_get_style_opa(usr->target, 0);
}

int32_t _ui_anim_callback_get_image_zoom(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_img_get_zoom(usr->target);
}

int32_t _ui_anim_callback_get_image_angle(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return lv_img_get_angle(usr->target);
}

int32_t _ui_anim_callback_get_image_frame(lv_anim_t* a)
{
   ui_anim_user_data_t *usr = (ui_anim_user_data_t *)a->user_data;
   return usr->val;
}

void _ui_arc_set_text_value( lv_obj_t *trg, lv_obj_t *src, const char *prefix, const char *postfix) 
{
   char buf[_UI_TEMPORARY_STRING_BUFFER_SIZE];
   lv_snprintf(buf, sizeof(buf), "%s%d%s", prefix, (int)lv_arc_get_value(src), postfix);
   lv_label_set_text(trg, buf);
}

void _ui_slider_set_text_value( lv_obj_t *trg, lv_obj_t *src, const char *prefix, const char *postfix) 
{
   char buf[_UI_TEMPORARY_STRING_BUFFER_SIZE];
   lv_snprintf(buf, sizeof(buf), "%s%d%s", prefix, (int)lv_slider_get_value(src), postfix);
   lv_label_set_text(trg, buf);
}
void _ui_checked_set_text_value( lv_obj_t *trg, lv_obj_t *src, const char *txt_on, const char *txt_off) 
{
    if (lv_obj_has_state(src,LV_STATE_CHECKED)) lv_label_set_text(trg,txt_on);
    else lv_label_set_text(trg,txt_off);
}

void _ui_spinbox_step(lv_obj_t * target, int val)
{
	if(val > 0) lv_spinbox_increment(target);
	else lv_spinbox_decrement(target);

	lv_event_send(target,LV_EVENT_VALUE_CHANGED, 0);
}

void _ui_switch_theme(int val)
{
#ifdef UI_THEME_ACTIVE
    ui_theme_set(val);
#endif
}

// Update icon recolor/opacity based on the current measured value and the
// configured zones/colors in `screen_configs`.
// If `value` is NAN, fallback to zone 1 (default).
void _ui_apply_icon_style(lv_obj_t *img, int screen, int gauge)
{
   if (!img) return;
   size_t total_screens = sizeof(screen_configs) / sizeof(screen_configs[0]);
   if (screen < 0 || (size_t)screen >= total_screens) return;
   if (gauge < 0 || gauge > 1) return;

   const char *icon_path = screen_configs[screen].icon_paths[gauge];
   ESP_LOGW(TAG_UI_HELPERS, "[ICON INIT] screen=%d gauge=%d path='%s'", screen, gauge, (icon_path ? icon_path : "NULL"));

   // If no icon path is configured, clear any stale image source and keep hidden.
   if (!icon_path || icon_path[0] == '\0') {
      lv_img_set_src(img, NULL);
      lv_obj_set_style_img_opa(img, LV_OPA_TRANSP, LV_PART_MAIN);
      lv_obj_add_flag(img, LV_OBJ_FLAG_HIDDEN);
      ESP_LOGW(TAG_UI_HELPERS, "[ICON INIT] screen=%d gauge=%d empty path - cleared src and hid icon", screen, gauge);
      lv_obj_invalidate(img);
      return;
   }

   // If the bottom gauge is globally disabled for this screen, ensure the
   // bottom icon remains hidden and skip further styling.
   if (gauge == 1 && screen_configs[screen].show_bottom == 0) {
      lv_obj_add_flag(img, LV_OBJ_FLAG_HIDDEN);
      ESP_LOGW(TAG_UI_HELPERS, "[ICON INIT] screen=%d gauge=%d bottom disabled - hiding icon", screen, gauge);
      return;
   }

   // Default to zone 1 values
   const char *colstr = screen_configs[screen].color[gauge][1];
   int transparent = screen_configs[screen].transparent[gauge][1];

   // Obtain runtime value (may be NAN)
   float runtime_value = ui_get_runtime_value(screen, gauge);

   // Find the zone index (1..4) whose min/max contains runtime_value.
   int chosen_zone = 1;
   for (int z = 1; z <= 4; ++z) {
      float mn = screen_configs[screen].min[gauge][z];
      float mx = screen_configs[screen].max[gauge][z];
      if (mn == mx) continue; // skip unconfigured zone
      if (!isnan(runtime_value) && runtime_value >= mn && runtime_value <= mx) { chosen_zone = z; break; }
      if (isnan(runtime_value) && (mn != 0.0f || mx != 0.0f)) { chosen_zone = z; break; }
   }

   // Diagnostic: Print transparent value for Min2 (zone 2) at runtime
   if (chosen_zone == 2) {
      ESP_LOGI(TAG_UI_HELPERS, "[DIAG] Min2 zone selected: screen=%d gauge=%d color='%s' transparent=%d min=%.2f max=%.2f runtime=%.2f",
         screen, gauge, screen_configs[screen].color[gauge][2], screen_configs[screen].transparent[gauge][2],
         screen_configs[screen].min[gauge][2], screen_configs[screen].max[gauge][2], runtime_value);
   }

   // Extra diagnostics for Screen 1, Gauge 1 (fuel icon)
   if (screen == 1 && gauge == 1) {
      bool is_hidden = lv_obj_has_flag(img, LV_OBJ_FLAG_HIDDEN);
      ESP_LOGI(TAG_UI_HELPERS, "[DIAG] Fuel icon: screen=%d gauge=%d chosen_zone=%d runtime=%.2f hidden=%d",
         screen, gauge, chosen_zone, runtime_value, is_hidden);
   }

   // Use chosen_zone values
   colstr = screen_configs[screen].color[gauge][chosen_zone];
   transparent = screen_configs[screen].transparent[gauge][chosen_zone];

   // Print diagnostic info at debug level
   ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p screen=%d gauge=%d chosen_zone=%d runtime=%.2f color='%s' transparent=%d",
      (void*)img, screen, gauge, chosen_zone, runtime_value, colstr ? colstr : "(null)", transparent);

   /* If the icon is a packed RGB565 binary (".bin"), it's typically a full-screen
    * background image. Applying an image recolor to a full-screen asset will tint
    * the entire display — treat these as non-recolorable to avoid coloring the
    * whole screen. */
   bool is_bin_asset = false;
   if (icon_path) {
      const char *ext = strrchr(icon_path, '.');
      if (ext && strcasecmp(ext, ".bin") == 0) is_bin_asset = true;
   }

   if (!is_bin_asset && colstr && colstr[0] == '#' && strlen(colstr) >= 7) {
      // parse #RRGGBB
      char hexbuf[7];
      memcpy(hexbuf, colstr+1, 6);
      hexbuf[6] = '\0';
      long hex = strtol(hexbuf, NULL, 16);
      uint32_t hex32 = (uint32_t)hex & 0xFFFFFF;
      lv_color_t recol = lv_color_hex(hex32);
      ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p path='%s' color_str='%s' parsed_hex=0x%06lX",
         (void*)img, screen_configs[screen].icon_paths[gauge], colstr, hex);
      // Treat pure white (#ffffff) as a sentinel meaning "no recolor" (use original asset).
      if (hex32 == 0xFFFFFF) {
         lv_obj_set_style_img_recolor_opa(img, LV_OPA_TRANSP, LV_PART_MAIN);
         transparent = 0; // override any configured transparency for white
         ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p white color -> disabling recolor and forcing opaque", (void*)img);
      } else {
         lv_obj_set_style_img_recolor(img, recol, LV_PART_MAIN);
         lv_obj_set_style_img_recolor_opa(img, LV_OPA_COVER, LV_PART_MAIN);
      }
   } else if (is_bin_asset) {
      // Don't apply recolor to full-screen binary assets.
      lv_obj_set_style_img_recolor_opa(img, LV_OPA_TRANSP, LV_PART_MAIN);
      ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p is .bin asset -> skipping recolor", (void*)img);
   } else {
      // No recolor configured; ensure recolor is disabled
      lv_obj_set_style_img_recolor_opa(img, LV_OPA_TRANSP, LV_PART_MAIN);
   }

   if (transparent) {
      // When the web UI 'Transparent' option is set, hide the icon completely
      // rather than merely reducing its opacity so it becomes invisible.
      lv_obj_add_flag(img, LV_OBJ_FLAG_HIDDEN);
      ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p -> HIDDEN (transparent option)", (void*)img);
   } else {
      // Ensure the icon is visible and fully opaque when not transparent
      lv_obj_clear_flag(img, LV_OBJ_FLAG_HIDDEN);
      lv_obj_set_style_img_opa(img, LV_OPA_COVER, LV_PART_MAIN);
      ESP_LOGD(TAG_UI_HELPERS, "[ICON STYLE] img=%p -> img_opa=LV_OPA_COVER (opaque)", (void*)img);
   }

   /* Removed diagnostic forced-opaque test — styling now driven by web UI + helper only. */

   /* Diagnostic: print the LVGL style values actually applied */
   {
      lv_color_t cur_recol = lv_obj_get_style_img_recolor(img, LV_PART_MAIN);
      int cur_recol_opa = lv_obj_get_style_img_recolor_opa(img, LV_PART_MAIN);
      int cur_img_opa = lv_obj_get_style_img_opa(img, LV_PART_MAIN);
      ESP_LOGD(TAG_UI_HELPERS, "[DIAG] LVGL style now: recol=0x%04x recol_opa=%d img_opa=%d", cur_recol.full, cur_recol_opa, cur_img_opa);
   }

   /* Force a redraw of the image to ensure style changes are applied immediately. */
   lv_obj_invalidate(img);
   
   // Log final icon state
   bool final_hidden = lv_obj_has_flag(img, LV_OBJ_FLAG_HIDDEN);
   uint8_t final_opa = lv_obj_get_style_img_opa(img, LV_PART_MAIN);
   lv_img_src_t src_type = lv_img_src_get_type((const void*)screen_configs[screen].icon_paths[gauge]);
   ESP_LOGW(TAG_UI_HELPERS, "[ICON FINAL] screen=%d gauge=%d hidden=%d opa=%d src_type=%d", 
      screen, gauge, final_hidden, final_opa, src_type);
   
      /* Apply configured icon position (override default UI-generated coords).
      * Positions: 0=top, 1=right, 2=bottom, 3=left
      */
      int pos = 0;
      if (screen_configs && screen >= 0) pos = screen_configs[screen].icon_pos[gauge];
      switch (pos) {
         case 0: // top
            lv_obj_set_align(img, LV_ALIGN_CENTER);
            lv_obj_set_x(img, 0);
            lv_obj_set_y(img, -70);
            break;
         case 1: // right
            lv_obj_set_align(img, LV_ALIGN_CENTER);
            lv_obj_set_x(img, 70);
            lv_obj_set_y(img, 0);
            break;
         case 2: // bottom
            lv_obj_set_align(img, LV_ALIGN_CENTER);
            lv_obj_set_x(img, 0);
            lv_obj_set_y(img, 70);
            break;
         case 3: // left
            lv_obj_set_align(img, LV_ALIGN_CENTER);
            lv_obj_set_x(img, -70);
            lv_obj_set_y(img, 0);
            break;
         default:
            break;
      }
}


